"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_api-client_ts"],{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: () => (/* binding */ apiClient),\n/* harmony export */   fetcher: () => (/* binding */ fetcher),\n/* harmony export */   generateChallenge: () => (/* binding */ generateChallenge),\n/* harmony export */   getSettings: () => (/* binding */ getSettings),\n/* harmony export */   getWordLists: () => (/* binding */ getWordLists),\n/* harmony export */   getWords: () => (/* binding */ getWords),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   resetSettings: () => (/* binding */ resetSettings),\n/* harmony export */   saveSingleTest: () => (/* binding */ saveSingleTest),\n/* harmony export */   syncLocalHistory: () => (/* binding */ syncLocalHistory),\n/* harmony export */   updateSettings: () => (/* binding */ updateSettings)\n/* harmony export */ });\n/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./history */ \"(app-pages-browser)/./src/lib/history.ts\");\n\nconst API_BASE_URL = \"http://localhost:8081\" || 0;\nclass ApiClient {\n    async makeRequest(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(API_BASE_URL).concat(endpoint);\n        const config = {\n            headers: {\n                'Content-Type': 'application/json',\n                ...options.headers\n            },\n            // Add timeout and better error handling\n            signal: AbortSignal.timeout(10000),\n            ...options\n        };\n        try {\n            const response = await fetch(url, config);\n            // Handle non-JSON responses or network errors\n            let data;\n            try {\n                data = await response.json();\n            } catch (e) {\n                throw new Error(\"Server returned invalid response. Status: \".concat(response.status));\n            }\n            if (!response.ok) {\n                // Provide more specific error messages based on status code\n                if (response.status === 0 || response.status >= 500) {\n                    throw new Error('Server is currently unavailable. Please try again later.');\n                } else if (response.status === 404) {\n                    throw new Error('The requested resource was not found.');\n                } else if (response.status === 401) {\n                    throw new Error('Invalid credentials. Please check your email and password.');\n                } else if (response.status === 409) {\n                    throw new Error('An account with this email already exists.');\n                } else {\n                    throw new Error((data === null || data === void 0 ? void 0 : data.error) || \"Request failed with status \".concat(response.status));\n                }\n            }\n            return data;\n        } catch (error) {\n            // Handle network errors and timeouts\n            if (error instanceof Error) {\n                if (error.name === 'AbortError' || error.name === 'TimeoutError') {\n                    throw new Error('Request timed out. Please check your connection and try again.');\n                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {\n                    throw new Error('Network error. Please check your internet connection and ensure the server is running.');\n                }\n                // Re-throw our custom errors\n                throw error;\n            }\n            throw new Error('An unexpected error occurred. Please try again.');\n        }\n    }\n    constructor(){\n        var _this = this;\n        // Use arrow functions to preserve 'this' context when destructured\n        this.registerUser = async (data)=>{\n            return this.makeRequest('/api/auth/register', {\n                method: 'POST',\n                body: JSON.stringify(data)\n            });\n        };\n        this.loginUser = async (data)=>{\n            return this.makeRequest('/api/auth/login', {\n                method: 'POST',\n                body: JSON.stringify(data)\n            });\n        };\n        this.syncLocalHistory = async (token)=>{\n            const localHistory = (0,_history__WEBPACK_IMPORTED_MODULE_0__.getTestHistory)();\n            // If no local history exists, return null\n            if (localHistory.length === 0) {\n                return null;\n            }\n            // Transform local TestResult format to match API expected format\n            const transformedHistory = localHistory.map((test)=>({\n                    wpm: test.wpm,\n                    accuracy: test.accuracy,\n                    rawWpm: test.wpm,\n                    consistency: null,\n                    config: {\n                        mode: test.mode,\n                        duration: test.duration,\n                        wordCount: test.wordCount,\n                        textSource: test.textSource,\n                        difficulty: test.difficulty,\n                        punctuation: test.punctuation\n                    },\n                    tags: [],\n                    timestamp: new Date(test.timestamp).toISOString()\n                }));\n            const response = await this.makeRequest('/api/me/tests/bulk', {\n                method: 'POST',\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                },\n                body: JSON.stringify({\n                    testResults: transformedHistory\n                })\n            });\n            // Clear local history after successful sync\n            (0,_history__WEBPACK_IMPORTED_MODULE_0__.clearTestHistory)();\n            return response;\n        };\n        this.generateChallenge = async (prompt, token)=>{\n            return this.makeRequest('/api/generate-challenge', {\n                method: 'POST',\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                },\n                body: JSON.stringify({\n                    prompt\n                })\n            });\n        };\n        this.saveSingleTest = async (result, token)=>{\n            // Transform local TestResult format to match API expected format\n            const transformedResult = {\n                wpm: result.wpm,\n                accuracy: result.accuracy,\n                rawWpm: result.wpm,\n                consistency: null,\n                config: {\n                    mode: result.mode,\n                    duration: result.duration,\n                    wordCount: result.wordCount,\n                    textSource: result.textSource,\n                    difficulty: result.difficulty,\n                    punctuation: result.punctuation\n                },\n                tags: [],\n                timestamp: new Date(result.timestamp).toISOString()\n            };\n            return this.makeRequest('/api/me/tests', {\n                method: 'POST',\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(transformedResult)\n            });\n        };\n        // Word Source API methods\n        this.getWords = async function() {\n            let list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'english1k', limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100, randomize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n            const params = new URLSearchParams({\n                list,\n                limit: limit.toString(),\n                randomize: randomize.toString()\n            });\n            // Add enhancement parameters if specified\n            if (options.punctuation !== undefined) {\n                params.append('punctuation', options.punctuation.toString());\n            }\n            if (options.numbers !== undefined) {\n                params.append('numbers', options.numbers.toString());\n            }\n            if (options.punctuationDensity) {\n                params.append('punctuation_density', options.punctuationDensity);\n            }\n            return _this.makeRequest(\"/api/words?\".concat(params.toString()));\n        };\n        this.getWordLists = async ()=>{\n            return this.makeRequest('/api/words/lists');\n        };\n        // Settings API methods\n        this.getSettings = async (token)=>{\n            return this.makeRequest('/api/me/settings', {\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                }\n            });\n        };\n        this.updateSettings = async (settings, token)=>{\n            return this.makeRequest('/api/me/settings', {\n                method: 'PUT',\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(settings)\n            });\n        };\n        this.resetSettings = async (token)=>{\n            return this.makeRequest('/api/me/settings', {\n                method: 'DELETE',\n                headers: {\n                    Authorization: \"Bearer \".concat(token)\n                }\n            });\n        };\n    }\n}\nconst apiClient = new ApiClient();\n// Export convenience functions with proper binding\nconst { registerUser, loginUser, syncLocalHistory, generateChallenge, saveSingleTest, getWords, getWordLists, getSettings, updateSettings, resetSettings } = apiClient;\n// SWR fetcher function for authenticated GET requests\nasync function fetcher(url, token) {\n    const response = await fetch(\"\".concat(API_BASE_URL).concat(url), {\n        headers: {\n            Authorization: \"Bearer \".concat(token),\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!response.ok) {\n        const data = await response.json();\n        const error = new Error('An error occurred while fetching the data.');\n        error.info = data;\n        error.status = response.status;\n        throw error;\n    }\n    return response.json();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQThFO0FBRTlFLE1BQU1FLGVBQWVDLHVCQUErQixJQUFJLENBQXVCO0FBaUYvRSxNQUFNRztJQUNKLE1BQWNDLFlBQ1pDLFFBQWdCLEVBRUo7WUFEWkMsVUFBQUEsaUVBQXVCLENBQUM7UUFFeEIsTUFBTUMsTUFBTSxHQUFrQkYsT0FBZk4sY0FBd0IsT0FBVE07UUFDOUIsTUFBTUcsU0FBc0I7WUFDMUJDLFNBQVM7Z0JBQ1AsZ0JBQWdCO2dCQUNoQixHQUFHSCxRQUFRRyxPQUFPO1lBQ3BCO1lBQ0Esd0NBQXdDO1lBQ3hDQyxRQUFRQyxZQUFZQyxPQUFPLENBQUM7WUFDNUIsR0FBR04sT0FBTztRQUNaO1FBRUEsSUFBSTtZQUNGLE1BQU1PLFdBQVcsTUFBTUMsTUFBTVAsS0FBS0M7WUFFbEMsOENBQThDO1lBQzlDLElBQUlPO1lBQ0osSUFBSTtnQkFDRkEsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBQzVCLEVBQUUsVUFBTTtnQkFDTixNQUFNLElBQUlDLE1BQ1IsNkNBQTZELE9BQWhCSixTQUFTSyxNQUFNO1lBRWhFO1lBRUEsSUFBSSxDQUFDTCxTQUFTTSxFQUFFLEVBQUU7Z0JBQ2hCLDREQUE0RDtnQkFDNUQsSUFBSU4sU0FBU0ssTUFBTSxLQUFLLEtBQUtMLFNBQVNLLE1BQU0sSUFBSSxLQUFLO29CQUNuRCxNQUFNLElBQUlELE1BQ1I7Z0JBRUosT0FBTyxJQUFJSixTQUFTSyxNQUFNLEtBQUssS0FBSztvQkFDbEMsTUFBTSxJQUFJRCxNQUFNO2dCQUNsQixPQUFPLElBQUlKLFNBQVNLLE1BQU0sS0FBSyxLQUFLO29CQUNsQyxNQUFNLElBQUlELE1BQ1I7Z0JBRUosT0FBTyxJQUFJSixTQUFTSyxNQUFNLEtBQUssS0FBSztvQkFDbEMsTUFBTSxJQUFJRCxNQUFNO2dCQUNsQixPQUFPO29CQUNMLE1BQU0sSUFBSUEsTUFDUkYs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QU9QLFNBQVNHLElBQUk7QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL2p1aG5rL3JlcG9zL3R5cGUvcGFja2FnZXMvd2ViL3NyYy9saWIvYXBpLWNsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRUZXN0SGlzdG9yeSwgY2xlYXJUZXN0SGlzdG9yeSwgdHlwZSBUZXN0UmVzdWx0IH0gZnJvbSAnLi9oaXN0b3J5JztcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAzJztcblxuaW50ZXJmYWNlIEF1dGhSZXNwb25zZSB7XG4gIHVzZXI6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIH07XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBdXRoUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCdWxrU3luY1Jlc3BvbnNlIHtcbiAgY291bnQ6IG51bWJlcjtcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgR2VuZXJhdGVDaGFsbGVuZ2VSZXNwb25zZSB7XG4gIHRleHQ6IHN0cmluZztcbiAgbWV0YWRhdGE6IHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICBkaWZmaWN1bHR5OiBzdHJpbmc7XG4gICAgY29udGV4dDogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgV29yZHNSZXNwb25zZSB7XG4gIHdvcmRzOiBzdHJpbmdbXTtcbiAgbWV0YWRhdGE6IHtcbiAgICBsaXN0OiBzdHJpbmc7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICB0b3RhbF9hdmFpbGFibGU6IG51bWJlcjtcbiAgfTtcbiAgZW5oYW5jZWRfdGV4dD86IHN0cmluZztcbiAgcHVuY3R1YXRpb25fZW5hYmxlZD86IGJvb2xlYW47XG4gIG51bWJlcnNfZW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBXb3JkTGlzdHNSZXNwb25zZSB7XG4gIGxpc3RzOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICB0b3RhbF93b3JkczogbnVtYmVyO1xuICB9Pjtcbn1cblxuaW50ZXJmYWNlIFNldHRpbmdzUmVzcG9uc2Uge1xuICAvLyBBcHBlYXJhbmNlXG4gIHRoZW1lOiBzdHJpbmc7XG4gIGZvbnQ6IHN0cmluZztcbiAgZm9udFNpemU6IG51bWJlcjtcbiAgY2FyZXRTdHlsZTogc3RyaW5nO1xuICBjYXJldENvbG9yOiBzdHJpbmc7XG4gIGNvbG9yU2NoZW1lOiBzdHJpbmc7XG4gIGFuaW1hdGlvbnM6IGJvb2xlYW47XG4gIHNtb290aENhcmV0OiBib29sZWFuO1xuICBzaG93V3BtQ291bnRlcjogYm9vbGVhbjtcbiAgc2hvd0FjY3VyYWN5Q291bnRlcjogYm9vbGVhbjtcbiAgLy8gQmVoYXZpb3JcbiAgc291bmRFZmZlY3RzOiBib29sZWFuO1xuICBrZXlGZWVkYmFjazogYm9vbGVhbjtcbiAgZGVmYXVsdE1vZGU6IHN0cmluZztcbiAgZGVmYXVsdERpZmZpY3VsdHk6IHN0cmluZztcbiAgZGVmYXVsdER1cmF0aW9uOiBudW1iZXI7XG4gIGRlZmF1bHRXb3JkQ291bnQ6IG51bWJlcjtcbiAgcGFjZUNhcmV0V3BtOiBudW1iZXI7XG4gIHBhY2VDYXJldEVuYWJsZWQ6IGJvb2xlYW47XG4gIGF1dG9TYXZlOiBib29sZWFuO1xuICBmb2N1c01vZGU6IGJvb2xlYW47XG4gIHF1aWNrUmVzdGFydDogYm9vbGVhbjtcbiAgYmxpbmRNb2RlOiBib29sZWFuO1xuICAvLyBUaW1lc3RhbXBzXG4gIGNyZWF0ZWRBdD86IHN0cmluZztcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xufVxuXG5jbGFzcyBBcGlDbGllbnQge1xuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0PFQ+KFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xuICAgIGNvbnN0IGNvbmZpZzogUmVxdWVzdEluaXQgPSB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgdGltZW91dCBhbmQgYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApLCAvLyAxMCBzZWNvbmQgdGltZW91dFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBjb25maWcpO1xuXG4gICAgICAvLyBIYW5kbGUgbm9uLUpTT04gcmVzcG9uc2VzIG9yIG5ldHdvcmsgZXJyb3JzXG4gICAgICBsZXQgZGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBTZXJ2ZXIgcmV0dXJuZWQgaW52YWxpZCByZXNwb25zZS4gU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gUHJvdmlkZSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzIGJhc2VkIG9uIHN0YXR1cyBjb2RlXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTZXJ2ZXIgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVxdWVzdGVkIHJlc291cmNlIHdhcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBjcmVkZW50aWFscy4gUGxlYXNlIGNoZWNrIHlvdXIgZW1haWwgYW5kIHBhc3N3b3JkLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBhY2NvdW50IHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBkYXRhPy5lcnJvciB8fCBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBhbmQgdGltZW91dHNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnUmVxdWVzdCB0aW1lZCBvdXQuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2Fpbi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSB8fFxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmtFcnJvcicpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uIGFuZCBlbnN1cmUgdGhlIHNlcnZlciBpcyBydW5uaW5nLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlLXRocm93IG91ciBjdXN0b20gZXJyb3JzXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZSBhcnJvdyBmdW5jdGlvbnMgdG8gcHJlc2VydmUgJ3RoaXMnIGNvbnRleHQgd2hlbiBkZXN0cnVjdHVyZWRcbiAgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKGRhdGE6IEF1dGhSZXF1ZXN0KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdDxBdXRoUmVzcG9uc2U+KCcvYXBpL2F1dGgvcmVnaXN0ZXInLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9O1xuXG4gIGxvZ2luVXNlciA9IGFzeW5jIChkYXRhOiBBdXRoUmVxdWVzdCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiA9PiB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3Q8QXV0aFJlc3BvbnNlPignL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfTtcblxuICBzeW5jTG9jYWxIaXN0b3J5ID0gYXN5bmMgKFxuICAgIHRva2VuOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxCdWxrU3luY1Jlc3BvbnNlIHwgbnVsbD4gPT4ge1xuICAgIGNvbnN0IGxvY2FsSGlzdG9yeSA9IGdldFRlc3RIaXN0b3J5KCk7XG5cbiAgICAvLyBJZiBubyBsb2NhbCBoaXN0b3J5IGV4aXN0cywgcmV0dXJuIG51bGxcbiAgICBpZiAobG9jYWxIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIFRlc3RSZXN1bHQgZm9ybWF0IHRvIG1hdGNoIEFQSSBleHBlY3RlZCBmb3JtYXRcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEhpc3RvcnkgPSBsb2NhbEhpc3RvcnkubWFwKCh0ZXN0OiBUZXN0UmVzdWx0KSA9PiAoe1xuICAgICAgd3BtOiB0ZXN0LndwbSxcbiAgICAgIGFjY3VyYWN5OiB0ZXN0LmFjY3VyYWN5LFxuICAgICAgcmF3V3BtOiB0ZXN0LndwbSwgLy8gVXNpbmcgd3BtIGFzIHJhd1dwbSBmb3Igbm93XG4gICAgICBjb25zaXN0ZW5jeTogbnVsbCwgLy8gTm90IHRyYWNrZWQgaW4gbG9jYWwgZm9ybWF0XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgbW9kZTogdGVzdC5tb2RlLFxuICAgICAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcbiAgICAgICAgd29yZENvdW50OiB0ZXN0LndvcmRDb3VudCxcbiAgICAgICAgdGV4dFNvdXJjZTogdGVzdC50ZXh0U291cmNlLFxuICAgICAgICBkaWZmaWN1bHR5OiB0ZXN0LmRpZmZpY3VsdHksXG4gICAgICAgIHB1bmN0dWF0aW9uOiB0ZXN0LnB1bmN0dWF0aW9uLFxuICAgICAgfSxcbiAgICAgIHRhZ3M6IFtdLCAvLyBOb3QgdHJhY2tlZCBpbiBsb2NhbCBmb3JtYXRcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGVzdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgfSkpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0PEJ1bGtTeW5jUmVzcG9uc2U+KFxuICAgICAgJy9hcGkvbWUvdGVzdHMvYnVsaycsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0ZXN0UmVzdWx0czogdHJhbnNmb3JtZWRIaXN0b3J5LFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2xlYXIgbG9jYWwgaGlzdG9yeSBhZnRlciBzdWNjZXNzZnVsIHN5bmNcbiAgICBjbGVhclRlc3RIaXN0b3J5KCk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG5cbiAgZ2VuZXJhdGVDaGFsbGVuZ2UgPSBhc3luYyAoXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPEdlbmVyYXRlQ2hhbGxlbmdlUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdDxHZW5lcmF0ZUNoYWxsZW5nZVJlc3BvbnNlPihcbiAgICAgICcvYXBpL2dlbmVyYXRlLWNoYWxsZW5nZScsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvbXB0IH0pLFxuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgc2F2ZVNpbmdsZVRlc3QgPSBhc3luYyAoXG4gICAgcmVzdWx0OiBUZXN0UmVzdWx0LFxuICAgIHRva2VuOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiA9PiB7XG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIFRlc3RSZXN1bHQgZm9ybWF0IHRvIG1hdGNoIEFQSSBleHBlY3RlZCBmb3JtYXRcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFJlc3VsdCA9IHtcbiAgICAgIHdwbTogcmVzdWx0LndwbSxcbiAgICAgIGFjY3VyYWN5OiByZXN1bHQuYWNjdXJhY3ksXG4gICAgICByYXdXcG06IHJlc3VsdC53cG0sIC8vIFVzaW5nIHdwbSBhcyByYXdXcG0gZm9yIG5vd1xuICAgICAgY29uc2lzdGVuY3k6IG51bGwsIC8vIE5vdCB0cmFja2VkIGluIGxvY2FsIGZvcm1hdFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIG1vZGU6IHJlc3VsdC5tb2RlLFxuICAgICAgICBkdXJhdGlvbjogcmVzdWx0LmR1cmF0aW9uLFxuICAgICAgICB3b3JkQ291bnQ6IHJlc3VsdC53b3JkQ291bnQsXG4gICAgICAgIHRleHRTb3VyY2U6IHJlc3VsdC50ZXh0U291cmNlLFxuICAgICAgICBkaWZmaWN1bHR5OiByZXN1bHQuZGlmZmljdWx0eSxcbiAgICAgICAgcHVuY3R1YXRpb246IHJlc3VsdC5wdW5jdHVhdGlvbixcbiAgICAgIH0sXG4gICAgICB0YWdzOiBbXSwgLy8gTm90IHRyYWNrZWQgaW4gbG9jYWwgZm9ybWF0XG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHJlc3VsdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PHsgbWVzc2FnZTogc3RyaW5nIH0+KCcvYXBpL21lL3Rlc3RzJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybWVkUmVzdWx0KSxcbiAgICB9KTtcbiAgfTtcblxuICAvLyBXb3JkIFNvdXJjZSBBUEkgbWV0aG9kc1xuICBnZXRXb3JkcyA9IGFzeW5jIChcbiAgICBsaXN0OiBzdHJpbmcgPSAnZW5nbGlzaDFrJyxcbiAgICBsaW1pdDogbnVtYmVyID0gMTAwLFxuICAgIHJhbmRvbWl6ZTogYm9vbGVhbiA9IHRydWUsXG4gICAgb3B0aW9uczoge1xuICAgICAgcHVuY3R1YXRpb24/OiBib29sZWFuO1xuICAgICAgbnVtYmVycz86IGJvb2xlYW47XG4gICAgICBwdW5jdHVhdGlvbkRlbnNpdHk/OiAnbGlnaHQnIHwgJ21lZGl1bScgfCAnaGVhdnknO1xuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFdvcmRzUmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIGxpc3QsXG4gICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgIHJhbmRvbWl6ZTogcmFuZG9taXplLnRvU3RyaW5nKCksXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgZW5oYW5jZW1lbnQgcGFyYW1ldGVycyBpZiBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5wdW5jdHVhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdwdW5jdHVhdGlvbicsIG9wdGlvbnMucHVuY3R1YXRpb24udG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm51bWJlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW1zLmFwcGVuZCgnbnVtYmVycycsIG9wdGlvbnMubnVtYmVycy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHVuY3R1YXRpb25EZW5zaXR5KSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdwdW5jdHVhdGlvbl9kZW5zaXR5Jywgb3B0aW9ucy5wdW5jdHVhdGlvbkRlbnNpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PFdvcmRzUmVzcG9uc2U+KGAvYXBpL3dvcmRzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gIH07XG5cbiAgZ2V0V29yZExpc3RzID0gYXN5bmMgKCk6IFByb21pc2U8V29yZExpc3RzUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdDxXb3JkTGlzdHNSZXNwb25zZT4oJy9hcGkvd29yZHMvbGlzdHMnKTtcbiAgfTtcblxuICAvLyBTZXR0aW5ncyBBUEkgbWV0aG9kc1xuICBnZXRTZXR0aW5ncyA9IGFzeW5jICh0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxTZXR0aW5nc1Jlc3BvbnNlPiA9PiB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3Q8U2V0dGluZ3NSZXNwb25zZT4oJy9hcGkvbWUvc2V0dGluZ3MnLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcblxuICB1cGRhdGVTZXR0aW5ncyA9IGFzeW5jIChcbiAgICBzZXR0aW5nczogUGFydGlhbDxTZXR0aW5nc1Jlc3BvbnNlPixcbiAgICB0b2tlbjogc3RyaW5nXG4gICk6IFByb21pc2U8U2V0dGluZ3NSZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PFNldHRpbmdzUmVzcG9uc2U+KCcvYXBpL21lL3NldHRpbmdzJywge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpLFxuICAgIH0pO1xuICB9O1xuXG4gIHJlc2V0U2V0dGluZ3MgPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4gPT4ge1xuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0PHsgbWVzc2FnZTogc3RyaW5nIH0+KCcvYXBpL21lL3NldHRpbmdzJywge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYXBpQ2xpZW50ID0gbmV3IEFwaUNsaWVudCgpO1xuXG4vLyBFeHBvcnQgY29udmVuaWVuY2UgZnVuY3Rpb25zIHdpdGggcHJvcGVyIGJpbmRpbmdcbmV4cG9ydCBjb25zdCB7XG4gIHJlZ2lzdGVyVXNlcixcbiAgbG9naW5Vc2VyLFxuICBzeW5jTG9jYWxIaXN0b3J5LFxuICBnZW5lcmF0ZUNoYWxsZW5nZSxcbiAgc2F2ZVNpbmdsZVRlc3QsXG4gIGdldFdvcmRzLFxuICBnZXRXb3JkTGlzdHMsXG4gIGdldFNldHRpbmdzLFxuICB1cGRhdGVTZXR0aW5ncyxcbiAgcmVzZXRTZXR0aW5ncyxcbn0gPSBhcGlDbGllbnQ7XG5cbi8vIFNXUiBmZXRjaGVyIGZ1bmN0aW9uIGZvciBhdXRoZW50aWNhdGVkIEdFVCByZXF1ZXN0c1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoZXIodXJsOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9JHt1cmx9YCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9LFxuICB9KTtcblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyB0aGUgZGF0YS4nXG4gICAgKSBhcyBFcnJvciAmIHtcbiAgICAgIGluZm86IHVua25vd247XG4gICAgICBzdGF0dXM6IG51bWJlcjtcbiAgICB9O1xuICAgIGVycm9yLmluZm8gPSBkYXRhO1xuICAgIGVycm9yLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG4iXSwibmFtZXMiOlsiZ2V0VGVzdEhpc3RvcnkiLCJjbGVhclRlc3RIaXN0b3J5IiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlDbGllbnQiLCJtYWtlUmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImNvbmZpZyIsImhlYWRlcnMiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJFcnJvciIsInN0YXR1cyIsIm9rIiwiZXJyb3IiLCJuYW1lIiwibWVzc2FnZSIsImluY2x1ZGVzIiwicmVnaXN0ZXJVc2VyIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2dpblVzZXIiLCJzeW5jTG9jYWxIaXN0b3J5IiwidG9rZW4iLCJsb2NhbEhpc3RvcnkiLCJsZW5ndGgiLCJ0cmFuc2Zvcm1lZEhpc3RvcnkiLCJtYXAiLCJ0ZXN0Iiwid3BtIiwiYWNjdXJhY3kiLCJyYXdXcG0iLCJjb25zaXN0ZW5jeSIsIm1vZGUiLCJkdXJhdGlvbiIsIndvcmRDb3VudCIsInRleHRTb3VyY2UiLCJkaWZmaWN1bHR5IiwicHVuY3R1YXRpb24iLCJ0YWdzIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiQXV0aG9yaXphdGlvbiIsInRlc3RSZXN1bHRzIiwiZ2VuZXJhdGVDaGFsbGVuZ2UiLCJwcm9tcHQiLCJzYXZlU2luZ2xlVGVzdCIsInJlc3VsdCIsInRyYW5zZm9ybWVkUmVzdWx0IiwiZ2V0V29yZHMiLCJsaXN0IiwibGltaXQiLCJyYW5kb21pemUiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInVuZGVmaW5lZCIsImFwcGVuZCIsIm51bWJlcnMiLCJwdW5jdHVhdGlvbkRlbnNpdHkiLCJnZXRXb3JkTGlzdHMiLCJnZXRTZXR0aW5ncyIsInVwZGF0ZVNldHRpbmdzIiwic2V0dGluZ3MiLCJyZXNldFNldHRpbmdzIiwiYXBpQ2xpZW50IiwiZmV0Y2hlciIsImluZm8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/history.ts":
/*!****************************!*\
  !*** ./src/lib/history.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAverageAccuracy: () => (/* binding */ calculateAverageAccuracy),\n/* harmony export */   calculateAverageWpm: () => (/* binding */ calculateAverageWpm),\n/* harmony export */   calculateHighestWpm: () => (/* binding */ calculateHighestWpm),\n/* harmony export */   clearTestHistory: () => (/* binding */ clearTestHistory),\n/* harmony export */   getTestHistory: () => (/* binding */ getTestHistory),\n/* harmony export */   getTestStatistics: () => (/* binding */ getTestStatistics),\n/* harmony export */   getTotalTestsTaken: () => (/* binding */ getTotalTestsTaken),\n/* harmony export */   saveTestResult: () => (/* binding */ saveTestResult)\n/* harmony export */ });\n// Test result interface matching GDD Section 4.2 schema\n// Storage key for localStorage\nconst STORAGE_KEY = 'typeamp-data';\n/**\n * Retrieves test history from localStorage\n * @returns Array of test results, empty array if no data exists\n */ function getTestHistory() {\n    if (false) {}\n    try {\n        const storedData = localStorage.getItem(STORAGE_KEY);\n        if (!storedData) {\n            return [];\n        }\n        const parsedData = JSON.parse(storedData);\n        // Ensure we have a testHistory array\n        if (!parsedData.testHistory || !Array.isArray(parsedData.testHistory)) {\n            return [];\n        }\n        return parsedData.testHistory;\n    } catch (error) {\n        console.error('Error retrieving test history:', error);\n        return [];\n    }\n}\n/**\n * Saves a new test result to localStorage\n * @param result - The test result to save\n */ function saveTestResult(result) {\n    if (false) {}\n    try {\n        // Get existing history\n        const existingHistory = getTestHistory();\n        // Add new result to the beginning of the array (most recent first)\n        const updatedHistory = [\n            result,\n            ...existingHistory\n        ];\n        // Limit history to last 100 results to prevent excessive storage\n        const limitedHistory = updatedHistory.slice(0, 100);\n        // Create the full data structure\n        const dataToStore = {\n            testHistory: limitedHistory,\n            lastUpdated: Date.now()\n        };\n        // Save to localStorage\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToStore));\n    } catch (error) {\n        console.error('Error saving test result:', error);\n    }\n}\n/**\n * Clears all test history from localStorage\n */ function clearTestHistory() {\n    if (false) {}\n    try {\n        localStorage.removeItem(STORAGE_KEY);\n    } catch (error) {\n        console.error('Error clearing test history:', error);\n    }\n}\n/**\n * Gets statistics from test history\n * @returns Object with calculated statistics\n */ function getTestStatistics() {\n    const history = getTestHistory();\n    if (history.length === 0) {\n        return {\n            totalTests: 0,\n            averageWpm: 0,\n            averageAccuracy: 0,\n            bestWpm: 0,\n            totalTimeTyping: 0\n        };\n    }\n    const totalTests = history.length;\n    const totalWpm = history.reduce((sum, test)=>sum + test.wpm, 0);\n    const totalAccuracy = history.reduce((sum, test)=>sum + test.accuracy, 0);\n    const bestWpm = Math.max(...history.map((test)=>test.wpm));\n    // Calculate total time spent typing (in seconds)\n    const totalTimeTyping = history.reduce((sum, test)=>{\n        if (test.mode === 'time' && test.duration) {\n            return sum + test.duration;\n        }\n        // For words/quote modes, estimate based on WPM\n        const estimatedTime = test.totalChars / 5 / test.wpm * 60;\n        return sum + estimatedTime;\n    }, 0);\n    return {\n        totalTests,\n        averageWpm: Math.round(totalWpm / totalTests),\n        averageAccuracy: Math.round(totalAccuracy / totalTests),\n        bestWpm,\n        totalTimeTyping: Math.round(totalTimeTyping)\n    };\n}\n/**\n * Calculate average WPM from test results\n * @param testResults - Array of test results\n * @returns Average WPM rounded to nearest integer\n */ function calculateAverageWpm(testResults) {\n    if (testResults.length === 0) return 0;\n    const totalWpm = testResults.reduce((sum, test)=>sum + test.wpm, 0);\n    return Math.round(totalWpm / testResults.length);\n}\n/**\n * Find highest WPM from test results\n * @param testResults - Array of test results\n * @returns Highest WPM achieved\n */ function calculateHighestWpm(testResults) {\n    if (testResults.length === 0) return 0;\n    return Math.max(...testResults.map((test)=>test.wpm));\n}\n/**\n * Calculate average accuracy from test results\n * @param testResults - Array of test results\n * @returns Average accuracy as percentage rounded to nearest integer\n */ function calculateAverageAccuracy(testResults) {\n    if (testResults.length === 0) return 0;\n    const totalAccuracy = testResults.reduce((sum, test)=>sum + test.accuracy, 0);\n    return Math.round(totalAccuracy / testResults.length);\n}\n/**\n * Get total number of tests taken\n * @param testResults - Array of test results\n * @returns Total number of tests\n */ function getTotalTestsTaken(testResults) {\n    return testResults.length;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBZ0JWO1FBQzVDRztRQUNBQyxpQkFBaUJRLEtBQUtPLEtBQUssQ0FBQ2Y7SUFDOUI7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTZ0Isb0JBQW9CQyxXQUF5QjtJQUMzRCxJQUFJQSxZQUFZdEIsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUNyQyxNQUFNTSxXQUFXZ0IsWUFBWWYsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE9BQVNELE1BQU1DLEtBQUtDLEdBQUcsRUFBRTtJQUNuRSxPQUFPRyxLQUFLTyxLQUFLLENBQUNkLFdBQVdnQixZQUFZdEIsTUFBTTtBQUNqRDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTdUIsb0JBQW9CRCxXQUF5QjtJQUMzRCxJQUFJQSxZQUFZdEIsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUNyQyxPQUFPYSxLQUFLQyxHQUFHLElBQUlRLFlBQVlQLEdBQUcsQ0FBQyxDQUFDTixPQUFTQSxLQUFLQyxHQUFHO0FBQ3ZEO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNjLHlCQUF5QkYsV0FBeUI7SUFDaEUsSUFBSUEsWUFBWXRCLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFDckMsTUFBTVcsZ0JBQWdCVyxZQUFZZixNQUFNLENBQ3RDLENBQUNDLEtBQUtDLE9BQVNELE1BQU1DLEtBQUtHLFFBQVEsRUFDbEM7SUFFRixPQUFPQyxLQUFLTyxLQUFLLENBQUNULGdCQUFnQlcsWUFBWXRCLE1BQU07QUFDdEQ7QUFFQTs7OztDQUlDLEdBQ00sU0FBU3lCLG1CQUFtQkgsV0FBeUI7SUFDMUQsT0FBT0EsWUFBWXRCLE1BQU07QUFDM0IiLCJzb3VyY2VzIjpbIi9ob21lL2p1aG5rL3JlcG9zL3R5cGUvcGFja2FnZXMvd2ViL3NyYy9saWIvaGlzdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUZXN0IHJlc3VsdCBpbnRlcmZhY2UgbWF0Y2hpbmcgR0REIFNlY3Rpb24gNC4yIHNjaGVtYVxuZXhwb3J0IGludGVyZmFjZSBUZXN0UmVzdWx0IHtcbiAgaWQ6IHN0cmluZzsgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0ZXN0XG4gIHRpbWVzdGFtcDogbnVtYmVyOyAvLyBVbml4IHRpbWVzdGFtcFxuICBtb2RlOiAndGltZScgfCAnd29yZHMnIHwgJ3F1b3RlJzsgLy8gVGVzdCBtb2RlXG4gIGR1cmF0aW9uPzogbnVtYmVyOyAvLyBUZXN0IGR1cmF0aW9uIChmb3IgdGltZSBtb2RlKVxuICB3b3JkQ291bnQ/OiBudW1iZXI7IC8vIFdvcmQgY291bnQgKGZvciB3b3JkcyBtb2RlKVxuICB0ZXh0U291cmNlOiBzdHJpbmc7IC8vIFRleHQgc291cmNlIHVzZWRcbiAgZGlmZmljdWx0eTogc3RyaW5nOyAvLyBEaWZmaWN1bHR5IGxldmVsXG4gIHB1bmN0dWF0aW9uOiBib29sZWFuOyAvLyBXaGV0aGVyIHB1bmN0dWF0aW9uIHdhcyBlbmFibGVkXG4gIHdwbTogbnVtYmVyOyAvLyBXb3JkcyBwZXIgbWludXRlXG4gIGFjY3VyYWN5OiBudW1iZXI7IC8vIEFjY3VyYWN5IHBlcmNlbnRhZ2VcbiAgdG90YWxDaGFyczogbnVtYmVyOyAvLyBUb3RhbCBjaGFyYWN0ZXJzIHR5cGVkXG4gIGNvcnJlY3RDaGFyczogbnVtYmVyOyAvLyBDb3JyZWN0IGNoYXJhY3RlcnNcbiAgaW5jb3JyZWN0Q2hhcnM6IG51bWJlcjsgLy8gSW5jb3JyZWN0IGNoYXJhY3RlcnNcbn1cblxuLy8gU3RvcmFnZSBrZXkgZm9yIGxvY2FsU3RvcmFnZVxuY29uc3QgU1RPUkFHRV9LRVkgPSAndHlwZWFtcC1kYXRhJztcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGVzdCBoaXN0b3J5IGZyb20gbG9jYWxTdG9yYWdlXG4gKiBAcmV0dXJucyBBcnJheSBvZiB0ZXN0IHJlc3VsdHMsIGVtcHR5IGFycmF5IGlmIG5vIGRhdGEgZXhpc3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXN0SGlzdG9yeSgpOiBUZXN0UmVzdWx0W10ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG5cbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShzdG9yZWREYXRhKTtcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdGVzdEhpc3RvcnkgYXJyYXlcbiAgICBpZiAoIXBhcnNlZERhdGEudGVzdEhpc3RvcnkgfHwgIUFycmF5LmlzQXJyYXkocGFyc2VkRGF0YS50ZXN0SGlzdG9yeSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkRGF0YS50ZXN0SGlzdG9yeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIHRlc3QgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogU2F2ZXMgYSBuZXcgdGVzdCByZXN1bHQgdG8gbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0gcmVzdWx0IC0gVGhlIHRlc3QgcmVzdWx0IHRvIHNhdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVUZXN0UmVzdWx0KHJlc3VsdDogVGVzdFJlc3VsdCk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIC8vIEdldCBleGlzdGluZyBoaXN0b3J5XG4gICAgY29uc3QgZXhpc3RpbmdIaXN0b3J5ID0gZ2V0VGVzdEhpc3RvcnkoKTtcblxuICAgIC8vIEFkZCBuZXcgcmVzdWx0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IChtb3N0IHJlY2VudCBmaXJzdClcbiAgICBjb25zdCB1cGRhdGVkSGlzdG9yeSA9IFtyZXN1bHQsIC4uLmV4aXN0aW5nSGlzdG9yeV07XG5cbiAgICAvLyBMaW1pdCBoaXN0b3J5IHRvIGxhc3QgMTAwIHJlc3VsdHMgdG8gcHJldmVudCBleGNlc3NpdmUgc3RvcmFnZVxuICAgIGNvbnN0IGxpbWl0ZWRIaXN0b3J5ID0gdXBkYXRlZEhpc3Rvcnkuc2xpY2UoMCwgMTAwKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgZnVsbCBkYXRhIHN0cnVjdHVyZVxuICAgIGNvbnN0IGRhdGFUb1N0b3JlID0ge1xuICAgICAgdGVzdEhpc3Rvcnk6IGxpbWl0ZWRIaXN0b3J5LFxuICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gICAgfTtcblxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGRhdGFUb1N0b3JlKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHRlc3QgcmVzdWx0OicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIENsZWFycyBhbGwgdGVzdCBoaXN0b3J5IGZyb20gbG9jYWxTdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclRlc3RIaXN0b3J5KCk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyB0ZXN0IGhpc3Rvcnk6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBzdGF0aXN0aWNzIGZyb20gdGVzdCBoaXN0b3J5XG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBjYWxjdWxhdGVkIHN0YXRpc3RpY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlc3RTdGF0aXN0aWNzKCkge1xuICBjb25zdCBoaXN0b3J5ID0gZ2V0VGVzdEhpc3RvcnkoKTtcblxuICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxUZXN0czogMCxcbiAgICAgIGF2ZXJhZ2VXcG06IDAsXG4gICAgICBhdmVyYWdlQWNjdXJhY3k6IDAsXG4gICAgICBiZXN0V3BtOiAwLFxuICAgICAgdG90YWxUaW1lVHlwaW5nOiAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdCB0b3RhbFRlc3RzID0gaGlzdG9yeS5sZW5ndGg7XG4gIGNvbnN0IHRvdGFsV3BtID0gaGlzdG9yeS5yZWR1Y2UoKHN1bSwgdGVzdCkgPT4gc3VtICsgdGVzdC53cG0sIDApO1xuICBjb25zdCB0b3RhbEFjY3VyYWN5ID0gaGlzdG9yeS5yZWR1Y2UoKHN1bSwgdGVzdCkgPT4gc3VtICsgdGVzdC5hY2N1cmFjeSwgMCk7XG4gIGNvbnN0IGJlc3RXcG0gPSBNYXRoLm1heCguLi5oaXN0b3J5Lm1hcCgodGVzdCkgPT4gdGVzdC53cG0pKTtcblxuICAvLyBDYWxjdWxhdGUgdG90YWwgdGltZSBzcGVudCB0eXBpbmcgKGluIHNlY29uZHMpXG4gIGNvbnN0IHRvdGFsVGltZVR5cGluZyA9IGhpc3RvcnkucmVkdWNlKChzdW0sIHRlc3QpID0+IHtcbiAgICBpZiAodGVzdC5tb2RlID09PSAndGltZScgJiYgdGVzdC5kdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHN1bSArIHRlc3QuZHVyYXRpb247XG4gICAgfVxuICAgIC8vIEZvciB3b3Jkcy9xdW90ZSBtb2RlcywgZXN0aW1hdGUgYmFzZWQgb24gV1BNXG4gICAgY29uc3QgZXN0aW1hdGVkVGltZSA9ICh0ZXN0LnRvdGFsQ2hhcnMgLyA1IC8gdGVzdC53cG0pICogNjA7XG4gICAgcmV0dXJuIHN1bSArIGVzdGltYXRlZFRpbWU7XG4gIH0sIDApO1xuXG4gIHJldHVybiB7XG4gICAgdG90YWxUZXN0cyxcbiAgICBhdmVyYWdlV3BtOiBNYXRoLnJvdW5kKHRvdGFsV3BtIC8gdG90YWxUZXN0cyksXG4gICAgYXZlcmFnZUFjY3VyYWN5OiBNYXRoLnJvdW5kKHRvdGFsQWNjdXJhY3kgLyB0b3RhbFRlc3RzKSxcbiAgICBiZXN0V3BtLFxuICAgIHRvdGFsVGltZVR5cGluZzogTWF0aC5yb3VuZCh0b3RhbFRpbWVUeXBpbmcpLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhdmVyYWdlIFdQTSBmcm9tIHRlc3QgcmVzdWx0c1xuICogQHBhcmFtIHRlc3RSZXN1bHRzIC0gQXJyYXkgb2YgdGVzdCByZXN1bHRzXG4gKiBAcmV0dXJucyBBdmVyYWdlIFdQTSByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZVdwbSh0ZXN0UmVzdWx0czogVGVzdFJlc3VsdFtdKTogbnVtYmVyIHtcbiAgaWYgKHRlc3RSZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIGNvbnN0IHRvdGFsV3BtID0gdGVzdFJlc3VsdHMucmVkdWNlKChzdW0sIHRlc3QpID0+IHN1bSArIHRlc3Qud3BtLCAwKTtcbiAgcmV0dXJuIE1hdGgucm91bmQodG90YWxXcG0gLyB0ZXN0UmVzdWx0cy5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEZpbmQgaGlnaGVzdCBXUE0gZnJvbSB0ZXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB0ZXN0UmVzdWx0cyAtIEFycmF5IG9mIHRlc3QgcmVzdWx0c1xuICogQHJldHVybnMgSGlnaGVzdCBXUE0gYWNoaWV2ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUhpZ2hlc3RXcG0odGVzdFJlc3VsdHM6IFRlc3RSZXN1bHRbXSk6IG51bWJlciB7XG4gIGlmICh0ZXN0UmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gTWF0aC5tYXgoLi4udGVzdFJlc3VsdHMubWFwKCh0ZXN0KSA9PiB0ZXN0LndwbSkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhdmVyYWdlIGFjY3VyYWN5IGZyb20gdGVzdCByZXN1bHRzXG4gKiBAcGFyYW0gdGVzdFJlc3VsdHMgLSBBcnJheSBvZiB0ZXN0IHJlc3VsdHNcbiAqIEByZXR1cm5zIEF2ZXJhZ2UgYWNjdXJhY3kgYXMgcGVyY2VudGFnZSByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZUFjY3VyYWN5KHRlc3RSZXN1bHRzOiBUZXN0UmVzdWx0W10pOiBudW1iZXIge1xuICBpZiAodGVzdFJlc3VsdHMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgY29uc3QgdG90YWxBY2N1cmFjeSA9IHRlc3RSZXN1bHRzLnJlZHVjZShcbiAgICAoc3VtLCB0ZXN0KSA9PiBzdW0gKyB0ZXN0LmFjY3VyYWN5LFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIE1hdGgucm91bmQodG90YWxBY2N1cmFjeSAvIHRlc3RSZXN1bHRzLmxlbmd0aCk7XG59XG5cbi8qKlxuICogR2V0IHRvdGFsIG51bWJlciBvZiB0ZXN0cyB0YWtlblxuICogQHBhcmFtIHRlc3RSZXN1bHRzIC0gQXJyYXkgb2YgdGVzdCByZXN1bHRzXG4gKiBAcmV0dXJucyBUb3RhbCBudW1iZXIgb2YgdGVzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvdGFsVGVzdHNUYWtlbih0ZXN0UmVzdWx0czogVGVzdFJlc3VsdFtdKTogbnVtYmVyIHtcbiAgcmV0dXJuIHRlc3RSZXN1bHRzLmxlbmd0aDtcbn1cbiJdLCJuYW1lcyI6WyJTVE9SQUdFX0tFWSIsImdldFRlc3RIaXN0b3J5Iiwic3RvcmVkRGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWREYXRhIiwiSlNPTiIsInBhcnNlIiwidGVzdEhpc3RvcnkiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvciIsImNvbnNvbGUiLCJzYXZlVGVzdFJlc3VsdCIsInJlc3VsdCIsImV4aXN0aW5nSGlzdG9yeSIsInVwZGF0ZWRIaXN0b3J5IiwibGltaXRlZEhpc3RvcnkiLCJzbGljZSIsImRhdGFUb1N0b3JlIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwibm93Iiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImNsZWFyVGVzdEhpc3RvcnkiLCJyZW1vdmVJdGVtIiwiZ2V0VGVzdFN0YXRpc3RpY3MiLCJoaXN0b3J5IiwibGVuZ3RoIiwidG90YWxUZXN0cyIsImF2ZXJhZ2VXcG0iLCJhdmVyYWdlQWNjdXJhY3kiLCJiZXN0V3BtIiwidG90YWxUaW1lVHlwaW5nIiwidG90YWxXcG0iLCJyZWR1Y2UiLCJzdW0iLCJ0ZXN0Iiwid3BtIiwidG90YWxBY2N1cmFjeSIsImFjY3VyYWN5IiwiTWF0aCIsIm1heCIsIm1hcCIsIm1vZGUiLCJkdXJhdGlvbiIsImVzdGltYXRlZFRpbWUiLCJ0b3RhbENoYXJzIiwicm91bmQiLCJjYWxjdWxhdGVBdmVyYWdlV3BtIiwidGVzdFJlc3VsdHMiLCJjYWxjdWxhdGVIaWdoZXN0V3BtIiwiY2FsY3VsYXRlQXZlcmFnZUFjY3VyYWN5IiwiZ2V0VG90YWxUZXN0c1Rha2VuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/history.ts\n"));

/***/ })

}]);