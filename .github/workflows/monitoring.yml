name: Monitoring & Health Checks

on:
  schedule:
    # Run health checks every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: monitoring-${{ github.workflow }}-${{ inputs.environment || 'scheduled' }}
  cancel-in-progress: false

env:
  STAGING_URL: ${{ secrets.STAGING_FRONTEND_URL }}
  PRODUCTION_URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}

jobs:
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ github.event_name == 'workflow_dispatch' && fromJson(format('["{0}"]', inputs.environment)) || fromJson('["staging", "production"]') }}
    steps:
      - name: Set environment URLs
        id: urls
        run: |
          if [ "${{ matrix.environment }}" = "staging" ]; then
            echo "base_url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT
            echo "api_url=${{ secrets.NEXT_PUBLIC_API_URL_STAGING }}" >> $GITHUB_OUTPUT
          else
            echo "base_url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT
            echo "api_url=${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }}" >> $GITHUB_OUTPUT
          fi

      - name: Check Frontend Health
        id: frontend-health
        run: |
          echo "Checking frontend health: ${{ steps.urls.outputs.base_url }}"
          
          # Check if frontend is accessible
          if curl -f -s --max-time 30 "${{ steps.urls.outputs.base_url }}" > /dev/null; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "✅ Frontend is accessible"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "❌ Frontend is not accessible"
            exit 1
          fi

      - name: Check API Health
        id: api-health
        run: |
          echo "Checking API health: ${{ steps.urls.outputs.api_url }}/health"
          
          # Check API health endpoint
          response=$(curl -f -s --max-time 30 "${{ steps.urls.outputs.api_url }}/health" || echo "failed")
          
          if echo "$response" | grep -q "healthy\|ok"; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "✅ API is healthy"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "❌ API health check failed"
            echo "Response: $response"
            exit 1
          fi

      - name: Check Database Connectivity
        id: db-health
        run: |
          echo "Checking database connectivity through API"
          
          # Check database status through API
          response=$(curl -f -s --max-time 30 "${{ steps.urls.outputs.api_url }}/api/status" || echo "failed")
          
          if [ "$response" != "failed" ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "✅ Database connectivity is healthy"
          else
            echo "status=degraded" >> $GITHUB_OUTPUT
            echo "⚠️ Database connectivity check failed"
          fi

      - name: Performance Check
        id: performance
        run: |
          echo "Running basic performance check"
          
          # Measure response time
          start_time=$(date +%s%N)
          curl -f -s --max-time 30 "${{ steps.urls.outputs.base_url }}" > /dev/null
          end_time=$(date +%s%N)
          
          response_time=$(( (end_time - start_time) / 1000000 )) # Convert to milliseconds
          
          echo "response_time=${response_time}" >> $GITHUB_OUTPUT
          echo "📊 Response time: ${response_time}ms"
          
          if [ $response_time -lt 2000 ]; then
            echo "performance=good" >> $GITHUB_OUTPUT
          elif [ $response_time -lt 5000 ]; then
            echo "performance=fair" >> $GITHUB_OUTPUT
          else
            echo "performance=poor" >> $GITHUB_OUTPUT
          fi

      - name: Report Status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ matrix.environment }}';
            const frontendHealth = '${{ steps.frontend-health.outputs.status }}';
            const apiHealth = '${{ steps.api-health.outputs.status }}';
            const dbHealth = '${{ steps.db-health.outputs.status }}';
            const performance = '${{ steps.performance.outputs.performance }}';
            const responseTime = '${{ steps.performance.outputs.response_time }}';
            
            const overallStatus = frontendHealth === 'healthy' && apiHealth === 'healthy' ? 'healthy' : 'unhealthy';
            
            const report = `# ${environment.toUpperCase()} Health Check Report
            
            **Overall Status**: ${overallStatus === 'healthy' ? '✅' : '❌'} ${overallStatus.toUpperCase()}
            **Timestamp**: ${new Date().toISOString()}
            
            ## Component Status
            - **Frontend**: ${frontendHealth === 'healthy' ? '✅' : '❌'} ${frontendHealth}
            - **API**: ${apiHealth === 'healthy' ? '✅' : '❌'} ${apiHealth}
            - **Database**: ${dbHealth === 'healthy' ? '✅' : dbHealth === 'degraded' ? '⚠️' : '❌'} ${dbHealth}
            
            ## Performance Metrics
            - **Response Time**: ${responseTime}ms
            - **Performance Rating**: ${performance === 'good' ? '✅' : performance === 'fair' ? '⚠️' : '❌'} ${performance}
            
            ## URLs
            - **Frontend**: ${{ steps.urls.outputs.base_url }}
            - **API**: ${{ steps.urls.outputs.api_url }}
            `;
            
            console.log(report);
            
            // Create or update monitoring issue if there are problems
            if (overallStatus !== 'healthy') {
              // This would create an issue for tracking problems
              // Implementation depends on your issue tracking preferences
              console.log('Health check failed - consider creating an issue for tracking');
            }

  lighthouse-audit:
    name: Lighthouse Performance Audit
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Lighthouse CI
        id: lighthouse
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            ${{ github.event.inputs.environment == 'staging' && secrets.STAGING_FRONTEND_URL || secrets.PRODUCTION_FRONTEND_URL }}
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Comment PR with Lighthouse Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const results = ${{ steps.lighthouse.outputs.manifest }};
            
            let comment = `## 🔍 Lighthouse Performance Audit Results\n\n`;
            comment += `**Environment**: ${{ github.event.inputs.environment }}\n`;
            comment += `**URL**: ${{ github.event.inputs.environment == 'staging' && secrets.STAGING_FRONTEND_URL || secrets.PRODUCTION_FRONTEND_URL }}\n\n`;
            
            if (results && results.length > 0) {
              const result = results[0];
              const categories = result.jsonPath ? require(result.jsonPath).categories : {};
              
              comment += `### Scores\n`;
              comment += `- **Performance**: ${Math.round((categories.performance?.score || 0) * 100)}%\n`;
              comment += `- **Accessibility**: ${Math.round((categories.accessibility?.score || 0) * 100)}%\n`;
              comment += `- **Best Practices**: ${Math.round((categories['best-practices']?.score || 0) * 100)}%\n`;
              comment += `- **SEO**: ${Math.round((categories.seo?.score || 0) * 100)}%\n\n`;
              
              if (result.summary) {
                comment += `[📊 View Full Report](${result.summary})`;
              }
            }
            
            console.log(comment);

  security-scan:
    name: Security Monitoring
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run security audit
        id: audit
        run: |
          echo "Running npm audit..."
          audit_output=$(npm audit --audit-level=moderate --json || true)
          
          # Parse audit results
          vulnerabilities=$(echo "$audit_output" | jq -r '.metadata.vulnerabilities.total // 0')
          critical=$(echo "$audit_output" | jq -r '.metadata.vulnerabilities.critical // 0')
          high=$(echo "$audit_output" | jq -r '.metadata.vulnerabilities.high // 0')
          moderate=$(echo "$audit_output" | jq -r '.metadata.vulnerabilities.moderate // 0')
          
          echo "vulnerabilities=$vulnerabilities" >> $GITHUB_OUTPUT
          echo "critical=$critical" >> $GITHUB_OUTPUT
          echo "high=$high" >> $GITHUB_OUTPUT
          echo "moderate=$moderate" >> $GITHUB_OUTPUT
          
          if [ "$critical" -gt 0 ] || [ "$high" -gt 0 ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "❌ Critical or high vulnerabilities found"
          elif [ "$moderate" -gt 5 ]; then
            echo "status=warning" >> $GITHUB_OUTPUT
            echo "⚠️ Multiple moderate vulnerabilities found"
          else
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "✅ Security audit passed"
          fi

      - name: Snyk Security Scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --fail-on=all
        continue-on-error: true

      - name: Security Report
        if: always()
        run: |
          echo "## 🔐 Security Scan Report"
          echo "**Total Vulnerabilities**: ${{ steps.audit.outputs.vulnerabilities }}"
          echo "**Critical**: ${{ steps.audit.outputs.critical }}"
          echo "**High**: ${{ steps.audit.outputs.high }}"
          echo "**Moderate**: ${{ steps.audit.outputs.moderate }}"
          echo "**Status**: ${{ steps.audit.outputs.status }}"

  notification:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [health-check, security-scan]
    if: always() && (failure() || needs.health-check.result == 'failure' || needs.security-scan.result == 'failure')
    steps:
      - name: Send Slack Alert
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          message="🚨 TypeAmp Monitoring Alert
          
          Health Check: ${{ needs.health-check.result }}
          Security Scan: ${{ needs.security-scan.result }}
          
          Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          Please check the GitHub Actions for details."
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$message\"}" \
            $SLACK_WEBHOOK_URL

      - name: Create Incident Issue
        if: needs.health-check.result == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `🚨 Production Health Check Failed - ${new Date().toISOString()}`;
            const body = `# Production Health Check Failure
            
            **Time**: ${new Date().toISOString()}
            **Workflow Run**: [${context.runId}](${context.payload.repository.html_url}/actions/runs/${context.runId})
            
            ## Investigation Steps
            - [ ] Check application logs
            - [ ] Verify infrastructure status
            - [ ] Check database connectivity
            - [ ] Review recent deployments
            - [ ] Monitor third-party service status
            
            ## Communication
            - [ ] Notify team via Slack
            - [ ] Update status page if applicable
            - [ ] Prepare customer communication if needed
            
            This issue was automatically created by the monitoring workflow.
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['incident', 'production', 'automated']
            });